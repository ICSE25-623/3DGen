# 3DGen: AI-Assisted Generation of Provably Correct Binary Format Parsers

This repository contains supplementary materials for ICSE 2025 submission #623. 

### 3DGen Agent
- Code and prompts for the 3DGen agent is included in the 3DGen-src/agents folder
- Examples and 3D manual are included in the 3DGen-src/examples and 3DGen-src/3d_manuals folders
- Scripts to generate and validate tests are in the main 3DGen-src/ folder
- packets.zip contains the test set of packets used for each protocol
- experiments.zip contains the generated specifications and agent logs for the experiments in the paper.

### 3DTestGen
- test1.smt2 contains the SMT2 encoding of an example message parser from the TestMessage.3d file, generated by 3DTestGen. This file is a replayable transcript of all the SMT2 commands generated by 3DTestGen and sent to Z3, along with comments showing the responses from Z3, to generate and retrieve positive and negative test cases with branch coverage depth 2.

# Branch coverage with 3DTestGen

In this supplement, we briefly cover how 3DTestGen produces tests that achieve branch coverage.

Recall the `message` parser from Section III of the paper. It has has two branches and four paths: fail to parse the first byte; fail because the first byte is less than 42; fail to parse the second byte; success.

Thus, to query Z3 for models that achieve a form of branch coverage, we instrument our encoding with branch tags---in practice, 3DTestGen does not instrument every branch, heuristically only picking branches of interest, focusing on those that involve value constraints and `casetype`s

Next, we introduce a global uninterpreted function, `branch-trace`, representing a trace of branches to be taken. The `State` argument to an encoded parser also contains a `branch-index` component which records a position in the branch trace. For a given branch trace, the encoding forces the parser to follow that trace of branches. By querying Z3 while fixing the branch trace, we obtain models of the `Input` that also are compatible with the trace, i.e., the `Input` is a byte sequence that forces the parser to follow the branch trace. Then, by simply enumerating the traces up to a user-specified branch depth in a depth-first fashion, we get Z3 to generate a diversity of `Input` models that achieve branch coverage.

We show a fragment of the `parse_message` parser encoding augmented with branch tags below. Note how each branch of the constraint check for `x > 42` is taken only if the corresponding branch tag in the trace also permits it (0 if the constraint holds, 1 if it does not.)

```
(define-fun parse-message ((s0 State)) State
  (let ((s1 (parse-uint8 s0)))
      (if (has-failed s1) s1
        (if (and (> (return-value s1) 42)
                 (= 0 (branch-trace (branch-index s1))))
            (parse_uint8 (incr-branch-index s1))
            (if (and (not (> (return-value s1) 42))
                     (= 1 (branch-trace (branch-index s1))))
                ...
```

Now, to generate models that explore a given trace of branches, we add the following assertions to the query to constrain the prefix of the branch trace recorded by the parser.

```
(assert (= (branch-index init) 0)) ;; start from index 0.
;; take the first branch in message.
(assert (and (= (branch-trace 0) 0))) 
;; make at least as many choices as branch-depth.
(assert (>= (branch-index (parse-message init)) 
              branch-depth)) 

```
